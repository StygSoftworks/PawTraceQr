import{r,j as M,F as _,R as E}from"./index-O7RRn4Et.js";import{u as b,c as g}from"./index-DOFNPw58.js";function U(e,t,{checkForDefaultPrevented:o=!0}={}){return function(u){if(e?.(u),o===!1||!u.defaultPrevented)return t?.(u)}}function q(e,t){const o=r.createContext(t),l=c=>{const{children:s,...n}=c,f=r.useMemo(()=>n,Object.values(n));return M.jsx(o.Provider,{value:f,children:s})};l.displayName=e+"Provider";function u(c){const s=r.useContext(o);if(s)return s;if(t!==void 0)return t;throw new Error(`\`${c}\` must be used within \`${e}\``)}return[l,u]}function N(e,t=[]){let o=[];function l(c,s){const n=r.createContext(s),f=o.length;o=[...o,s];const m=a=>{const{scope:I,children:v,...R}=a,p=I?.[e]?.[f]||n,d=r.useMemo(()=>R,Object.values(R));return M.jsx(p.Provider,{value:d,children:v})};m.displayName=c+"Provider";function i(a,I){const v=I?.[e]?.[f]||n,R=r.useContext(v);if(R)return R;if(s!==void 0)return s;throw new Error(`\`${a}\` must be used within \`${c}\``)}return[m,i]}const u=()=>{const c=o.map(s=>r.createContext(s));return function(n){const f=n?.[e]||c;return r.useMemo(()=>({[`__scope${e}`]:{...n,[e]:f}}),[n,f])}};return u.scopeName=e,[l,j(u,...t)]}function j(...e){const t=e[0];if(e.length===1)return t;const o=()=>{const l=e.map(u=>({useScope:u(),scopeName:u.scopeName}));return function(c){const s=l.reduce((n,{useScope:f,scopeName:m})=>{const a=f(c)[`__scope${m}`];return{...n,...a}},{});return r.useMemo(()=>({[`__scope${t.scopeName}`]:s}),[s])}};return o.scopeName=t.scopeName,o}var $=globalThis?.document?r.useLayoutEffect:()=>{},A=_[" useId ".trim().toString()]||(()=>{}),O=0;function B(e){const[t,o]=r.useState(A());return $(()=>{o(l=>l??String(O++))},[e]),e||(t?`radix-${t}`:"")}var T=_[" useInsertionEffect ".trim().toString()]||$;function V({prop:e,defaultProp:t,onChange:o=()=>{},caller:l}){const[u,c,s]=D({defaultProp:t,onChange:o}),n=e!==void 0,f=n?e:u;{const i=r.useRef(e!==void 0);r.useEffect(()=>{const a=i.current;a!==n&&console.warn(`${l} is changing from ${a?"controlled":"uncontrolled"} to ${n?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),i.current=n},[n,l])}const m=r.useCallback(i=>{if(n){const a=L(i)?i(e):i;a!==e&&s.current?.(a)}else c(i)},[n,e,c,s]);return[f,m]}function D({defaultProp:e,onChange:t}){const[o,l]=r.useState(e),u=r.useRef(o),c=r.useRef(t);return T(()=>{c.current=t},[t]),r.useEffect(()=>{u.current!==o&&(c.current?.(o),u.current=o)},[o,u]),[o,l,c]}function L(e){return typeof e=="function"}function z(e){const t=r.useRef(e);return r.useEffect(()=>{t.current=e}),r.useMemo(()=>(...o)=>t.current?.(...o),[])}function G(e){const t=e+"CollectionProvider",[o,l]=N(t),[u,c]=o(t,{collectionRef:{current:null},itemMap:new Map}),s=p=>{const{scope:d,children:h}=p,C=E.useRef(null),x=E.useRef(new Map).current;return M.jsx(u,{scope:d,itemMap:x,collectionRef:C,children:h})};s.displayName=t;const n=e+"CollectionSlot",f=g(n),m=E.forwardRef((p,d)=>{const{scope:h,children:C}=p,x=c(n,h),S=b(d,x.collectionRef);return M.jsx(f,{ref:S,children:C})});m.displayName=n;const i=e+"CollectionItemSlot",a="data-radix-collection-item",I=g(i),v=E.forwardRef((p,d)=>{const{scope:h,children:C,...x}=p,S=E.useRef(null),w=b(d,S),P=c(i,h);return E.useEffect(()=>(P.itemMap.set(S,{ref:S,...x}),()=>void P.itemMap.delete(S))),M.jsx(I,{[a]:"",ref:w,children:C})});v.displayName=i;function R(p){const d=c(e+"CollectionConsumer",p);return E.useCallback(()=>{const C=d.collectionRef.current;if(!C)return[];const x=Array.from(C.querySelectorAll(`[${a}]`));return Array.from(d.itemMap.values()).sort((P,y)=>x.indexOf(P.ref.current)-x.indexOf(y.ref.current))},[d.collectionRef,d.itemMap])}return[{Provider:s,Slot:m,ItemSlot:v},R,l]}var k=r.createContext(void 0);function J(e){const t=r.useContext(k);return e||t||"ltr"}export{B as a,U as b,N as c,z as d,$ as e,G as f,J as g,q as h,V as u};
